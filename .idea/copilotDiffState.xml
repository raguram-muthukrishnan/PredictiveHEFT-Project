<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/WorkflowSim-1.0/sources/org/workflowsim/WorkflowPlanner.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WorkflowSim-1.0/sources/org/workflowsim/WorkflowPlanner.java" />
              <option name="originalContent" value="/**&#10; * Copyright 2012-2013 University Of Southern California&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not&#10; * use this file except in compliance with the License. You may obtain a copy of&#10; * the License at&#10; *&#10; * http://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT&#10; * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the&#10; * License for the specific language governing permissions and limitations under&#10; * the License.&#10; */&#10;package org.workflowsim;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import org.cloudbus.cloudsim.Log;&#10;import org.cloudbus.cloudsim.core.CloudSimTags;&#10;import org.cloudbus.cloudsim.core.SimEntity;&#10;import org.cloudbus.cloudsim.core.SimEvent;&#10;import org.workflowsim.planning.BasePlanningAlgorithm;&#10;import org.workflowsim.planning.DHEFTPlanningAlgorithm;&#10;import org.workflowsim.planning.HEFTPlanningAlgorithm;&#10;import org.workflowsim.planning.RandomPlanningAlgorithm;&#10;import org.workflowsim.utils.Parameters;&#10;import org.workflowsim.utils.Parameters.PlanningAlgorithm;&#10;&#10;/**&#10; * WorkflowPlanner supports dynamic planning. In the future we will have global&#10; * and static algorithm here. The WorkflowSim starts from WorkflowPlanner. It&#10; * picks up a planning algorithm based on the configuration&#10; *&#10; * @author Weiwei Chen&#10; * @since WorkflowSim Toolkit 1.0&#10; * @date Apr 9, 2013&#10; *&#10; */&#10;public final class WorkflowPlanner extends SimEntity {&#10;&#10;    /**&#10;     * The task list.&#10;     */&#10;    protected List&lt; Task&gt; taskList;&#10;    /**&#10;     * The workflow parser.&#10;     */&#10;    protected WorkflowParser parser;&#10;    /**&#10;     * The associated clustering engine.&#10;     */&#10;    private int clusteringEngineId;&#10;    private ClusteringEngine clusteringEngine;&#10;&#10;    /**&#10;     * Created a new WorkflowPlanner object.&#10;     *&#10;     * @param name name to be associated with this entity (as required by&#10;     * Sim_entity class from simjava package)&#10;     * @throws Exception the exception&#10;     * @pre name != null&#10;     * @post $none&#10;     */&#10;    public WorkflowPlanner(String name) throws Exception {&#10;        this(name, 1);&#10;    }&#10;&#10;    public WorkflowPlanner(String name, int schedulers) throws Exception {&#10;        super(name);&#10;&#10;        setTaskList(new ArrayList&lt;&gt;());&#10;        this.clusteringEngine = new ClusteringEngine(name + &quot;_Merger_&quot;, schedulers);&#10;        this.clusteringEngineId = this.clusteringEngine.getId();&#10;        this.parser = new WorkflowParser(getClusteringEngine().getWorkflowEngine().getSchedulerId(0));&#10;&#10;    }&#10;&#10;    /**&#10;     * Gets the clustering engine id&#10;     *&#10;     * @return clustering engine id&#10;     */&#10;    public int getClusteringEngineId() {&#10;        return this.clusteringEngineId;&#10;    }&#10;&#10;    /**&#10;     * Gets the clustering engine&#10;     *&#10;     * @return the clustering engine&#10;     */&#10;    public ClusteringEngine getClusteringEngine() {&#10;        return this.clusteringEngine;&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow parser&#10;     *&#10;     * @return the workflow parser&#10;     */&#10;    public WorkflowParser getWorkflowParser() {&#10;        return this.parser;&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow engine id&#10;     *&#10;     * @return the workflow engine id&#10;     */&#10;    public int getWorkflowEngineId() {&#10;        return getClusteringEngine().getWorkflowEngineId();&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow engine&#10;     *&#10;     * @return the workflow engine&#10;     */&#10;    public WorkflowEngine getWorkflowEngine() {&#10;        return getClusteringEngine().getWorkflowEngine();&#10;    }&#10;&#10;    /**&#10;     * Processes events available for this Broker.&#10;     *&#10;     * @param ev a SimEvent object&#10;     * @pre ev != null&#10;     * @post $none&#10;     */&#10;    @Override&#10;    public void processEvent(SimEvent ev) {&#10;        switch (ev.getTag()) {&#10;            case WorkflowSimTags.START_SIMULATION:&#10;                getWorkflowParser().parse();&#10;                setTaskList(getWorkflowParser().getTaskList());&#10;                processPlanning();&#10;                processImpactFactors(getTaskList());&#10;                sendNow(getClusteringEngineId(), WorkflowSimTags.JOB_SUBMIT, getTaskList());&#10;                break;&#10;            case CloudSimTags.END_OF_SIMULATION:&#10;                shutdownEntity();&#10;                break;&#10;            // other unknown tags are processed by this method&#10;            default:&#10;                processOtherEvent(ev);&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void processPlanning() {&#10;        if (Parameters.getPlanningAlgorithm().equals(PlanningAlgorithm.INVALID)) {&#10;            return;&#10;        }&#10;        BasePlanningAlgorithm planner = getPlanningAlgorithm(Parameters.getPlanningAlgorithm());&#10;        &#10;        planner.setTaskList(getTaskList());&#10;        planner.setVmList(getWorkflowEngine().getAllVmList());&#10;        try {&#10;            planner.run();&#10;        } catch (Exception e) {&#10;            Log.printLine(&quot;Error in configuring scheduler_method&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Switch between multiple planners. Based on planner.method&#10;     *&#10;     * @param name the SCHMethod name&#10;     * @return the scheduler that extends BaseScheduler&#10;     */&#10;    private BasePlanningAlgorithm getPlanningAlgorithm(PlanningAlgorithm name) {&#10;        BasePlanningAlgorithm planner;&#10;&#10;        // choose which scheduler to use. Make sure you have add related enum in&#10;        //Parameters.java&#10;        switch (name) {&#10;            //by default it is FCFS_SCH&#10;            case INVALID:&#10;                planner = null;&#10;                break;&#10;            case RANDOM:&#10;                planner = new RandomPlanningAlgorithm();&#10;                break;&#10;            case HEFT:&#10;                planner = new HEFTPlanningAlgorithm();&#10;                break;&#10;            case PREDICTIVE_HEFT: // ADD THIS CASE BLOCK&#10;                planner = new PredictiveHEFTPlanner();&#10;                break;&#10;            case DHEFT:&#10;                planner = new DHEFTPlanningAlgorithm();&#10;                break;&#10;            default:&#10;                planner = null;&#10;                break;&#10;        }&#10;        return planner;&#10;    }&#10;&#10;    /**&#10;     * Add impact factor for each task. This is useful in task balanced&#10;     * clustering algorithm It is for research purpose and thus it is optional.&#10;     *&#10;     * @param taskList all the tasks&#10;     */&#10;    private void processImpactFactors(List&lt;Task&gt; taskList) {&#10;        List&lt;Task&gt; exits = new ArrayList&lt;&gt;();&#10;        for (Task task : taskList) {&#10;            if (task.getChildList().isEmpty()) {&#10;                exits.add(task);&#10;            }&#10;        }&#10;        double avg = 1.0 / exits.size();&#10;        for (Task task : exits) {&#10;            addImpact(task, avg);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add impact factor for one particular task&#10;     *&#10;     * @param task, the task&#10;     * @param impact , the impact factor&#10;     */&#10;    private void addImpact(Task task, double impact) {&#10;&#10;        task.setImpact(task.getImpact() + impact);&#10;        int size = task.getParentList().size();&#10;        if (size &gt; 0) {&#10;            double avg = impact / size;&#10;            for (Task parent : task.getParentList()) {&#10;                addImpact(parent, avg);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Overrides this method when making a new and different type of Broker.&#10;&#10;     *&#10;     * @param ev a SimEvent object&#10;     * @pre ev != null&#10;     * @post $none&#10;     */&#10;    protected void processOtherEvent(SimEvent ev) {&#10;        if (ev == null) {&#10;            Log.printLine(getName() + &quot;.processOtherEvent(): &quot; + &quot;Error - an event is null.&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.printLine(getName() + &quot;.processOtherEvent(): &quot;&#10;                + &quot;Error - event unknown by this DatacenterBroker.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Send an internal event communicating the end of the simulation.&#10;     *&#10;     * @pre $none&#10;     * @post $none&#10;     */&#10;    protected void finishExecution() {&#10;        //sendNow(getId(), CloudSimTags.END_OF_SIMULATION);&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     * @see cloudsim.core.SimEntity#shutdownEntity()&#10;     */&#10;    @Override&#10;    public void shutdownEntity() {&#10;        Log.printLine(getName() + &quot; is shutting down...&quot;);&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     * @see cloudsim.core.SimEntity#startEntity()&#10;     */&#10;    @Override&#10;    public void startEntity() {&#10;        Log.printLine(&quot;Starting WorkflowSim &quot; + Parameters.getVersion());&#10;        Log.printLine(getName() + &quot; is starting...&quot;);&#10;        schedule(getId(), 0, WorkflowSimTags.START_SIMULATION);&#10;    }&#10;&#10;    /**&#10;     * Gets the task list.&#10;     *&#10;     * @return the task list&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public List&lt;Task&gt; getTaskList() {&#10;        return (List&lt;Task&gt;) taskList;&#10;    }&#10;&#10;    /**&#10;     * Sets the task list.&#10;     *&#10;     * @param taskList&#10;     */&#10;    protected void setTaskList(List&lt;Task&gt; taskList) {&#10;        this.taskList = taskList;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Copyright 2012-2013 University Of Southern California&#10; *&#10; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not&#10; * use this file except in compliance with the License. You may obtain a copy of&#10; * the License at&#10; *&#10; * http://www.apache.org/licenses/LICENSE-2.0&#10; *&#10; * Unless required by applicable law or agreed to in writing, software&#10; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT&#10; * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the&#10; * License for the specific language governing permissions and limitations under&#10; * the License.&#10; */&#10;package org.workflowsim;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import org.cloudbus.cloudsim.Log;&#10;import org.cloudbus.cloudsim.core.CloudSimTags;&#10;import org.cloudbus.cloudsim.core.SimEntity;&#10;import org.cloudbus.cloudsim.core.SimEvent;&#10;import org.workflowsim.planning.BasePlanningAlgorithm;&#10;import org.workflowsim.planning.DHEFTPlanningAlgorithm;&#10;import org.workflowsim.planning.HEFTPlanningAlgorithm;&#10;import org.workflowsim.planning.PredictiveHEFTPlanner;&#10;import org.workflowsim.planning.RandomPlanningAlgorithm;&#10;import org.workflowsim.utils.Parameters;&#10;import org.workflowsim.utils.Parameters.PlanningAlgorithm;&#10;&#10;/**&#10; * WorkflowPlanner supports dynamic planning. In the future we will have global&#10; * and static algorithm here. The WorkflowSim starts from WorkflowPlanner. It&#10; * picks up a planning algorithm based on the configuration&#10; *&#10; * @author Weiwei Chen&#10; * @since WorkflowSim Toolkit 1.0&#10; * @date Apr 9, 2013&#10; *&#10; */&#10;public final class WorkflowPlanner extends SimEntity {&#10;&#10;    /**&#10;     * The task list.&#10;     */&#10;    protected List&lt; Task&gt; taskList;&#10;    /**&#10;     * The workflow parser.&#10;     */&#10;    protected WorkflowParser parser;&#10;    /**&#10;     * The associated clustering engine.&#10;     */&#10;    private int clusteringEngineId;&#10;    private ClusteringEngine clusteringEngine;&#10;&#10;    /**&#10;     * Created a new WorkflowPlanner object.&#10;     *&#10;     * @param name name to be associated with this entity (as required by&#10;     * Sim_entity class from simjava package)&#10;     * @throws Exception the exception&#10;     * @pre name != null&#10;     * @post $none&#10;     */&#10;    public WorkflowPlanner(String name) throws Exception {&#10;        this(name, 1);&#10;    }&#10;&#10;    public WorkflowPlanner(String name, int schedulers) throws Exception {&#10;        super(name);&#10;&#10;        setTaskList(new ArrayList&lt;&gt;());&#10;        this.clusteringEngine = new ClusteringEngine(name + &quot;_Merger_&quot;, schedulers);&#10;        this.clusteringEngineId = this.clusteringEngine.getId();&#10;        this.parser = new WorkflowParser(getClusteringEngine().getWorkflowEngine().getSchedulerId(0));&#10;&#10;    }&#10;&#10;    /**&#10;     * Gets the clustering engine id&#10;     *&#10;     * @return clustering engine id&#10;     */&#10;    public int getClusteringEngineId() {&#10;        return this.clusteringEngineId;&#10;    }&#10;&#10;    /**&#10;     * Gets the clustering engine&#10;     *&#10;     * @return the clustering engine&#10;     */&#10;    public ClusteringEngine getClusteringEngine() {&#10;        return this.clusteringEngine;&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow parser&#10;     *&#10;     * @return the workflow parser&#10;     */&#10;    public WorkflowParser getWorkflowParser() {&#10;        return this.parser;&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow engine id&#10;     *&#10;     * @return the workflow engine id&#10;     */&#10;    public int getWorkflowEngineId() {&#10;        return getClusteringEngine().getWorkflowEngineId();&#10;    }&#10;&#10;    /**&#10;     * Gets the workflow engine&#10;     *&#10;     * @return the workflow engine&#10;     */&#10;    public WorkflowEngine getWorkflowEngine() {&#10;        return getClusteringEngine().getWorkflowEngine();&#10;    }&#10;&#10;    /**&#10;     * Processes events available for this Broker.&#10;     *&#10;     * @param ev a SimEvent object&#10;     * @pre ev != null&#10;     * @post $none&#10;     */&#10;    @Override&#10;    public void processEvent(SimEvent ev) {&#10;        switch (ev.getTag()) {&#10;            case WorkflowSimTags.START_SIMULATION:&#10;                getWorkflowParser().parse();&#10;                setTaskList(getWorkflowParser().getTaskList());&#10;                processPlanning();&#10;                processImpactFactors(getTaskList());&#10;                sendNow(getClusteringEngineId(), WorkflowSimTags.JOB_SUBMIT, getTaskList());&#10;                break;&#10;            case CloudSimTags.END_OF_SIMULATION:&#10;                shutdownEntity();&#10;                break;&#10;            // other unknown tags are processed by this method&#10;            default:&#10;                processOtherEvent(ev);&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void processPlanning() {&#10;        if (Parameters.getPlanningAlgorithm().equals(PlanningAlgorithm.INVALID)) {&#10;            return;&#10;        }&#10;        BasePlanningAlgorithm planner = getPlanningAlgorithm(Parameters.getPlanningAlgorithm());&#10;        &#10;        planner.setTaskList(getTaskList());&#10;        planner.setVmList(getWorkflowEngine().getAllVmList());&#10;        try {&#10;            planner.run();&#10;        } catch (Exception e) {&#10;            Log.printLine(&quot;Error in configuring scheduler_method&quot;);&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Switch between multiple planners. Based on planner.method&#10;     *&#10;     * @param name the SCHMethod name&#10;     * @return the scheduler that extends BaseScheduler&#10;     */&#10;    private BasePlanningAlgorithm getPlanningAlgorithm(PlanningAlgorithm name) {&#10;        BasePlanningAlgorithm planner;&#10;&#10;        // choose which scheduler to use. Make sure you have add related enum in&#10;        //Parameters.java&#10;        switch (name) {&#10;            //by default it is FCFS_SCH&#10;            case INVALID:&#10;                planner = null;&#10;                break;&#10;            case RANDOM:&#10;                planner = new RandomPlanningAlgorithm();&#10;                break;&#10;            case HEFT:&#10;                planner = new HEFTPlanningAlgorithm();&#10;                break;&#10;            case PREDICTIVE_HEFT: // ADD THIS CASE BLOCK&#10;                planner = new PredictiveHEFTPlanner();&#10;                break;&#10;            case DHEFT:&#10;                planner = new DHEFTPlanningAlgorithm();&#10;                break;&#10;            default:&#10;                planner = null;&#10;                break;&#10;        }&#10;        return planner;&#10;    }&#10;&#10;    /**&#10;     * Add impact factor for each task. This is useful in task balanced&#10;     * clustering algorithm It is for research purpose and thus it is optional.&#10;     *&#10;     * @param taskList all the tasks&#10;     */&#10;    private void processImpactFactors(List&lt;Task&gt; taskList) {&#10;        List&lt;Task&gt; exits = new ArrayList&lt;&gt;();&#10;        for (Task task : taskList) {&#10;            if (task.getChildList().isEmpty()) {&#10;                exits.add(task);&#10;            }&#10;        }&#10;        double avg = 1.0 / exits.size();&#10;        for (Task task : exits) {&#10;            addImpact(task, avg);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add impact factor for one particular task&#10;     *&#10;     * @param task, the task&#10;     * @param impact , the impact factor&#10;     */&#10;    private void addImpact(Task task, double impact) {&#10;&#10;        task.setImpact(task.getImpact() + impact);&#10;        int size = task.getParentList().size();&#10;        if (size &gt; 0) {&#10;            double avg = impact / size;&#10;            for (Task parent : task.getParentList()) {&#10;                addImpact(parent, avg);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Overrides this method when making a new and different type of Broker.&#10;&#10;     *&#10;     * @param ev a SimEvent object&#10;     * @pre ev != null&#10;     * @post $none&#10;     */&#10;    protected void processOtherEvent(SimEvent ev) {&#10;        if (ev == null) {&#10;            Log.printLine(getName() + &quot;.processOtherEvent(): &quot; + &quot;Error - an event is null.&quot;);&#10;            return;&#10;        }&#10;&#10;        Log.printLine(getName() + &quot;.processOtherEvent(): &quot;&#10;                + &quot;Error - event unknown by this DatacenterBroker.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Send an internal event communicating the end of the simulation.&#10;     *&#10;     * @pre $none&#10;     * @post $none&#10;     */&#10;    protected void finishExecution() {&#10;        //sendNow(getId(), CloudSimTags.END_OF_SIMULATION);&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     * @see cloudsim.core.SimEntity#shutdownEntity()&#10;     */&#10;    @Override&#10;    public void shutdownEntity() {&#10;        Log.printLine(getName() + &quot; is shutting down...&quot;);&#10;    }&#10;&#10;    /*&#10;     * (non-Javadoc)&#10;     * @see cloudsim.core.SimEntity#startEntity()&#10;     */&#10;    @Override&#10;    public void startEntity() {&#10;        Log.printLine(&quot;Starting WorkflowSim &quot; + Parameters.getVersion());&#10;        Log.printLine(getName() + &quot; is starting...&quot;);&#10;        schedule(getId(), 0, WorkflowSimTags.START_SIMULATION);&#10;    }&#10;&#10;    /**&#10;     * Gets the task list.&#10;     *&#10;     * @return the task list&#10;     */&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public List&lt;Task&gt; getTaskList() {&#10;        return (List&lt;Task&gt;) taskList;&#10;    }&#10;&#10;    /**&#10;     * Sets the task list.&#10;     *&#10;     * @param taskList&#10;     */&#10;    protected void setTaskList(List&lt;Task&gt; taskList) {&#10;        this.taskList = taskList;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>